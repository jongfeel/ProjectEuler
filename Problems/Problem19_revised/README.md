# Problem 19 revised

## Problem 19 link

[https://github.com/jongfeel/ProjectEuler/tree/master/Problems/Problem19](https://github.com/jongfeel/ProjectEuler/tree/master/Problems/Problem19)

## Why?

이 문제도 풀어놓고 사실 찜찜했는데, 문제에 월별 일수와 윤년의 개념 그리고 윤년을 판단하는 방법이 주어졌음에도 불구하고 활용하지 않았다는 점이 제일 컸다.

그리고 이왕 이렇게 된거 문제에 주어진 정보를 모두 활용해서 푸는게 문제를 푸는 사람의 성의라고 생각하기 때문에 다시 풀게 됐다.

이건 프로그래밍 스킬이나 라이브러리 사용 능력이 얼마나 뛰어난가가 현대의 프로그래머의 자질이라고 본다면

프로젝트 오일러 문제를 푸는 사람의 자질은 주어진 문제를 분석하고 수학적으로 풀어낼 수 있는 사람이 자질이라고 본다.

> 문제를 해결하는건 중요하지만, 주어진 조건에 부합하도록 문제를 해결하는게 더 중요한 것 같다.

## Solve

- 새로 풀게 될 문제에서는 for문을 세번 돌린다.
  - 첫번째 for문은 1900년 부터 2000년까지 각 년도별로 도는 for문이고
  - 두번째 for문은 1월 부터 12월 까지 각 월별로 도는 for문인데 여기까지는 이전에 푼 문제와 같다.
  - 마지막 세번째 for문은 1일 부터 월별로 다르도록 28, 29, 30, 31일까지 도는 for문이다.
- 년도를 도는 for문에서는 윤년을 체크해야 한다.
  - 4로 나누어 떨어지는 해: 윤년
  - 400으로 나누어 떨어지는 해: 윤년
  - 그런데 400으로 나누어 떨어지는 해는 4로도 나누어 떨어지므로 굳이 두 조건식을 만들 필요 없이 4로 나누어 떨어지는 해를 윤년으로 판단한다.
  - 또 4로 나누어 떨어지지만 100으로 나누어 떨어지는 해는 윤년이 아닌 걸로 계산해야 하지만 문제에는 그런 조건은 주어지지 않았으므로 넘어간다.
    - 사실 4로 나누어 떨어지면서 100으로 나누어 떨어지는 해는 2000년인데, 공교롭게도 400으로 나누어 떨어지는 해이기도 하므로 결국 4로 나누어 떨어지는 해를 윤년으로 해도 무방하다.
  - 윤년은 년도 자체에 변화가 있는게 아니라 2월의 일수에 변화가 있으므로 (28일 or 29일) 월별 일수 판단하는 if문에 함께 넣어준다.
- 월을 도는 for문에서는 조건을 여러개 둬야 한다.
  - 9, 4, 6, 11월은 30일
  - 나머지는 31일: 1, 3, 5, 7, 8, 10, 12
  - 이 와중에 2월은 28일인데, 하필 윤년이면 29일로 계산한다.
  - 31일을 가진 달이 제일 많으므로 아래와 같이 코드를 짜본다.

``` csharp
int dayOfMonth = 31; // 1, 3, 5, 7, 8, 10, 12 month
if (month == 4 || month == 6 || month == 9 || month == 11)
{
  dayOfMonth = 30;
}
else if (month == 2)
{
  if (year % 4 == 0)
  {
    dayOfMonth = 29;
  }
  else
  {
    dayOfMonth = 28;
  }
}
```

- 가장 안쪽의 for문은 월별 일 수 만큼 for문이 돌 건데
  - 미리 초기값 0으로 해둔 dayCount 변수를 하나씩 증가시킨다.
  - 1900년 1월 1일은 월요일이었으므로 dayCount를 계속해서 더해 나갔을 때 7으로 나누어 떨어진다면 그 날은 일요일이 된다는 판단을 해 준다.
  - 그와 동시에 가장 안쪽의 for문이 1인지도 함께 판단해 매월 1일이 일요일이었는지 체크해서 별도로 sundayCount 변수에 하나씩 더해 준다.
  - 하지만 구해야 하는 년도의 범위는 1901년, 즉 20세기 기간을 구해야 하므로 실제 sundayCount는 1901년이 시작되는 해부터 구해본다.
  - 이 부분도 함정일 수 있고 주어진 정보를 활용해야 하는 부분일 수도 있는데, 1901년 1월 1일이 화요일인걸 알고 시작해도 상관 없으나 주어진 정보는 1900년 1월 1일 월요일이므로 1900년 부터 for문을 돌고 1901년 부터 1일이 일요일인 날을 계산해보도록 한다.

``` csharp
dayCount++;
if (year >= 1901 && dayCount % 7 == 0 && day == 1)
```

## Programming memories (추억)

- 1987년 ~~국민학생~~초등학생 때 컴퓨터학원을 다니며 배웠던 프로그램 중에 하나가 달력 출력하는 프로그램이었다.
- 하드디스크는 없고 IBM DOS가 설치된 360KB 용량의 5.25 인치 2D 플로피 디스크로 A 드라이브에서 부팅을 하고 같은 2D 플로피 디스크를 B 드라이브에 넣어 프로그램을 저장하던 그 시절 컴퓨터로 프로그래밍이라는 걸 했었다.
- BASIC이라는 언어로 짰는데 기본 로직은 지금 c#으로 프로그램 짠 것 처럼 대략 50~100줄 정도면 짤 수 있었고 출력하는 부분을 좀 더 정성을 들여 짜야 했다.
- 왜냐하면 년, 월을 입력하면 요일 부터 해서 7칸으로 출력되게 맞추고 그 맞춘 줄에 따라 입력한 년, 월에 해당하는 일이 쭉 출력되게 만들어야 했기 때문이다.

대략 이런 느낌으로 나오게 했었다.

2020, 7
|MON|TUE|WED|THU|FRI|SAT|SUN|
|---|---|---|---|---|---|---|
|   |   | 1 | 2 | 3 | 4 | 5 |
| 6 | 7 | 8 | 9 |10 |11 |12 |
|13 |14 |15 |16 |17 |18 |19 |
|20 |21 |22 |23 |24 |25 |26 |
|27 |28 |29 |30 |31 |   |   |

- 여러가지 논란거리가 있는데
  - 시작이 월요일이냐, 일요일이냐에 따라 이미 짠 코드 수정하기의 난이도 상승
  - 년, 월을 한번 입력하고 한번 출력하게 하냐, 계속 입력하고 계속 출력하게 하냐에 따라 분기 처리
  - 잘못된 년도, 월 입력할 때 예외 처리
  - Tab, Space에 따라 table이 삐뚤어지는 걸 어떻게 바로 잡아서 출력하게 할 것인가에 대한 고민
  - 이외 여러가지가 있었던 것 같다.
- 9살 밖에 안됐던 순수했던 어린 시절 학원에서 이 프로그램 짜는 데만 며칠이 걸렸던 거 같은데 초보 프로그래머에게 for문과 if문 그리고 현실 세계의 문제인 달력을 가져와 예외 처리 및 테스트까지 훈련하는데는 이만한 프로그램이 없었다는 점에서 지금 생각해 봐도 좋은 문제인 것 같고, 30년도 더 지난 지금 그 때 그 컴퓨터 보다 수억배는 빠른 컴퓨터에서 지금과 같은 달력 계산하는 로직을 짜는 나를 보고 있으니 세월이 참 많이 흘렀다는 걸 느낀다.